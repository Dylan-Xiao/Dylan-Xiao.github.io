---
layout:     post
title:      "Hello 2020"
subtitle:   " \"Hello World, Hello Blog\""
date:       2020-04-14 18:54:00+0800
author:     "小迪伦"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - ICS
    - 实验
---

# MallocLab 实验报告

姓名：<u>肖文璇</u> 学号：<u>2018202163</u>



## 方法一：隐式空闲链表

### 内存管理结构

采用CS:APP提供的隐式空闲链表结构。

**内存块**：由头部、脚部、有效载荷与填充部分组成。头部和脚部由块大小和分配状态组成，块大小按双字对齐，这种结构便于查看当前块与前后块的起始位置、块大小与状态。

![image-20200406161122896](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200406161122896.png)



**堆的结构**：堆的第一个字是双字边界对齐的不使用的填充字，后面紧跟着8字节的序言块，仅有头部与脚部组成，永不释放。序言块后紧跟着多个由malloc或free调用创建的普通块。在堆的结尾设4字节的结尾块，仅由头部组成。通过序言块与结尾块的使用，能避免讨论边界条件的复杂性。

![image-20200406161516545](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200406161516545.png)



### 基础算法

#### 宏定义

通过一系列宏定义来简便强制类型转换与指针运算。

~~~c++
//每次扩展堆的大小
#define CHUNKSIZE (1 << 12)

// 向双字节对齐
#define ALIGN(size) (((size) + (ALIGNMENT - 1)) & ~0x7)

// 每次扩展堆的块大小，扩展很多是为了减少系统调用，提升性能
#define CHUNKSIZE (1 << 12)

// 将块大小与分配状态打包
#define PACK(size, alloc) ((size) | (alloc))

// 读写地址P的一个字
#define GET(p) (*(unsigned int *)(p))
#define PUT(p, val) (*(unsigned int *)(p) = (val))

// 提取块大小与分配状态
#define GET_SIZE(p) (GET(p) & ~0x7)
#define GET_ALLOC(p) (GET(p) & 0x1)

// 计算一个块的头部地址与尾部地址
#define HDRP(bp) ((char *)(bp)-WSIZE)
#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)

// 计算出块bp前/后的块地址
#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE((char *)(bp)-WSIZE))
#define PREV_BLKP(bp) ((char *)(bp)-GET_SIZE((char *)(bp)-DSIZE))
~~~



#### 辅助函数

##### 1.  extend_heap

~~~c++
static void *extend_heap(size_t words) {
  char *bp;
  size_t size = ALIGN(words);

  if ((long)(bp = mem_sbrk(size)) == -1)
    return NULL;

  // 设置扩展出的空闲块的边界标记
  PUT(HDRP(bp), PACK(size, 0));
  PUT(FTRP(bp), PACK(size, 0));

  // 设置新结尾块
  PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1));

  // 检查是否能合并附近空闲块
  return coalesce(bp);
}
~~~

extend_heap函数将在初始化堆的时候调用，将堆扩展CHUNKSIZE字节。当malloc函数在空闲链表中找不到合适的空闲块时，也将调用extend_heap函数进行扩展堆操作。



##### 2. place

~~~c++
static void *place(void *bp, size_t asize) {
  size_t csize = GET_SIZE(HDRP(bp));
  size_t left_size = csize - asize; //该块减去需要的大小剩余的大小
  void *next_bp = NULL;

  if ((left_size) < (2 * DSIZE)) {
    //如果剩余的大小不足以形成一个新块
    PUT(HDRP(bp), PACK(csize, 1));
    PUT(FTRP(bp), PACK(csize, 1));
    return bp;
  }
  else {
    //剩余的大小可以分出一个新块
    PUT(HDRP(bp), PACK(asize, 1));
    PUT(FTRP(bp), PACK(asize, 1));
    next_bp = NEXT_BLKP(bp);
    PUT(HDRP(next_bp), PACK(left_size, 0));
    PUT(FTRP(next_bp), PACK(left_size, 0));
    return bp;
  }

  return bp;
}
~~~

place函数将在malloc函数中调用，当找到一个合适的空闲块，空闲块的空间减去新块所需的空间所剩余的空间足以形成新块时，place函数将会切割这个空闲块，形成一个已分配的块与一个空闲块，提高空间利用率；若剩余的空间不足，将直接把这个块设为已分配块。



##### 3. coalesce

~~~c++
static void *coalesce(void *bp) {
  size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));
  size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));
  size_t size = GET_SIZE(HDRP(bp));

  if (prev_alloc && next_alloc) {
    //前后均为分配块，不合并
    return bp;
  }

  else if (prev_alloc && !next_alloc) {
    //前面的块已分配，后面的块为空闲块，合并后面的
    size += GET_SIZE(HDRP(NEXT_BLKP(bp)));
    PUT(HDRP(bp), PACK(size, 0));
    PUT(FTRP(bp), PACK(size, 0));
  }

  else if (!prev_alloc && next_alloc) {
    //后面的块已分配，前面的块为空闲块，与前面合并
    size += GET_SIZE(HDRP(PREV_BLKP(bp)));
    PUT(FTRP(bp), PACK(size, 0));
    PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));
    bp = PREV_BLKP(bp);
  }

  else {
    //前后都为空闲块，合并三块
    size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));
    PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));
    PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0));
    bp = PREV_BLKP(bp);
  }

  return bp;
}
~~~

coalesce在free函数中调用，当释放一个块时，coalesce函数会检查这个块周围的块是否为空闲的，若为空闲的就将它们合并，减少外部碎片的产生。



##### 4. fint_fit

~~~c++
static void *find_fit(size_t asize) {
  char *heap_listp = (char *)mem_heap_lo() + 2 * WSIZE;

  void *bp;

  for (bp = heap_listp; GET_SIZE(HDRP(bp)) > 0; bp = NEXT_BLKP(bp)) {
    //遍历空闲链表
    if (!GET_ALLOC(HDRP(bp)) && (asize <= GET_SIZE(HDRP(bp)))) {
        return bp;
    }
  }
    
  return NULL;
}
~~~

find_fit在malloc函数中调用，用以在空闲链表中寻找合适的空闲块。基础算法采用first_fit方式，从头遍历空闲链表，选择第一个合适的块。



#### 分配器函数

##### 1. mm_init

~~~c++
int mm_init(void) {
  //初始化堆
  char *heap_listp = 0;
  char *head = (char *)mem_heap_lo();

  if ((heap_listp = mem_sbrk(4 * WSIZE)) == (void *)-1)
    return -1;

  PUT(heap_listp, 0);
  PUT(heap_listp + (1 * WSIZE), PACK(DSIZE, 1));
  PUT(heap_listp + (2 * WSIZE), PACK(DSIZE, 1));
  PUT(heap_listp + (3 * WSIZE), PACK(0, 1));
  heap_listp += (2 * WSIZE);

  //扩展堆
  if (extend_heap(CHUNKSIZE) == NULL)
    return -1;
  return 0;
}
~~~

mm_init函数从内存系统得到4个字，并将它们初始化，创建一个空的空闲链表，然后调用extend_heap函数，将堆扩展CHUNKSIZE字节，并且创建初始的空闲块。



##### 2. mm_malloc

~~~c++
void *mm_malloc(size_t size) {
  size_t asize;
  size_t extendsize;
  void *bp = NULL;
  char *heap_listp = (char *)mem_heap_lo() + 2 * WSIZE;

  if (heap_listp == 0) {
    mm_init();
  }

  // 忽略虚假指令
  if (size == 0)
    return NULL;

  // 将size双字节对齐
  if (size <= DSIZE) {
    size = 2 * DSIZE;
  } else {
    size = ALIGN(size + DSIZE);
  }

  //寻找合适的位置并放置
  if ((bp = find_fit(asize)) != NULL) {
    bp = place(bp, asize);
    return bp;
  }

  //没有合适的位置，需要扩展堆
  extendsize = MAX(asize, CHUNKSIZE);
  if ((bp = extend_heap(extendsize / WSIZE)) == NULL)
    return NULL;

  bp = place(bp, asize);
  return bp;
}
~~~

应用通过调用mm_malloc函数来向内存请求大小为size字节的块。函数先检查请求的真假，然后调整请求块的大小，满足头部与脚部，双字对齐的空间。然后它使用find_fit函数搜索空闲链表寻找合适的空闲块，如果有合适的空闲块，分配器将调用place函数分割多余部分，返回新分配地址；如果没有合适的块，它将调用extend_heap函数扩展堆，并返回指向新分配块的指针。



##### 3. mm_free

~~~c++
void mm_free(void *bp) {
  // 获取该块的大小
  if (bp == 0)
    return;

  char *heap_listp = (char *)mem_heap_lo() + 2 * WSIZE;

  size_t size = GET_SIZE(HDRP(bp));

  if (heap_listp == 0) {
    mm_init();
  }

  // 将该块的边界标记置为0
  PUT(HDRP(bp), PACK(size, 0));
  PUT(FTRP(bp), PACK(size, 0));

  // 检查是否能够与前后块合并
  coalesce(bp);
}
~~~

应用调用mm_free函数来释放一个以前分配的块，这个函数释放请求的块，然后调用coalesce函数检查是否能与前后块进行合并。



##### 4. mm_realloc

~~~c++
void *mm_realloc(void *ptr, size_t size) {
  void *newptr = ptr;
  int left_size;

  // 如果size等于0，等同于free功能
  if (size == 0) {
    mm_free(ptr);
    return 0;
  }

  // 如果ptr为空，等同于malloc功能
  if (ptr == NULL) {
    return mm_malloc(size);
  }

  // 将size双字节对齐
  if (size <= DSIZE) {
    size = 2 * DSIZE;
  } else {
    size = ALIGN(size + DSIZE);
  }

  if ((left_size = GET_SIZE(HDRP(ptr)) - size) >= 0) {
    // 如果size小于原来块的大小，直接返回原来的块
    return ptr;
  }
  else {
    newptr = mm_malloc(size);

    if (!newptr)
      return 0;

    memcpy(newptr, ptr, GET_SIZE(HDRP(ptr)));
    mm_free(ptr);
  }

  return newptr;
}
~~~

应用调用mm_realloc函数来调整一个以前分配的块的大小，realloc函数将先检查请求的真假，然后调整请求块的大小，满足头部与脚部，双字对齐的空间。然后它比较新的size与已分配块的size大小，如果新的size小于原来块的size，则直接返回原来的块；如果新的size大于原来块的size，则调用malloc函数新寻找一个块，并将旧块复制到新块中。



#### 测试分数

![image-20200330213513937](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200330213513937.png)

可以看到在空间利用率上除了9、10两个需要的realloc函数较一般，而且在吞吐量的表现上较差，因此需要提升程序的空间利用率与效率。



### 优化思路

#### 1. Fit方式

##### Best_fit

基础版本的first_fit方式在空间利用率上较一般，尝试使用best_fit方式。

~~~c++
static void *find_fit(size_t asize) {
  char *heap_listp = (char *)mem_heap_lo() + 2 * WSIZE;

  void *bp;
  void *best_bp = NULL;
  int min_size = 1 << 20;
  int test_size;

  for (bp = heap_listp; GET_SIZE(HDRP(bp)) > 0; bp = NEXT_BLKP(bp)) {
    test_size = GET_SIZE(HDRP(bp)) - asize;
    if (!GET_ALLOC(HDRP(bp)) && (test_size >= 0)) {
      if (test_size <= min_size) {
        min_size = test_size;
        best_bp = bp;
      }
    }
  }

  return best_bp;
}
~~~

best_fit遍历所有的空闲块，找到合适的块中最小的那一个，测试结果如下：

![image-20200405170328045](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200405170328045.png)



可以看到在空间利用率和程序效率上有一丝丝提升，但是效果并不大。因为其实在无论哪种fit方式，如果找到一个很大的块，place函数会进行切割，分离出多余的部分，不会造成很多浪费，因此在空间利用率上差别不大。而first_fit与best_fit需要从头进行搜索合适的块，在时间上会较长，程序效率较差，因此尝试next_fit。



##### Next_fit

~~~c++
static void *find_fit(size_t asize) {
  char *heap_listp = (char *)mem_heap_lo() + 2 * WSIZE;
  char *head = (char *)mem_heap_lo();
  char *last_ptr = GET(head);

  char *oldlast_ptr = last_ptr;

  for (; GET_SIZE(HDRP(last_ptr)) > 0; last_ptr = NEXT_BLKP(last_ptr))
    if (!GET_ALLOC(HDRP(last_ptr)) && (asize <= GET_SIZE(HDRP(last_ptr)))) {
      PUT(head, last_ptr);
      return last_ptr;
    }

  for (last_ptr = heap_listp; last_ptr < oldlast_ptr;
       last_ptr = NEXT_BLKP(last_ptr))
    if (!GET_ALLOC(HDRP(last_ptr)) && (asize <= GET_SIZE(HDRP(last_ptr)))) {
      PUT(head, last_ptr);
      return last_ptr;
    }

  return NULL;
}
~~~

Next_fit方式在每次搜索完合适的链表后，记录这个位置，下次搜索时从这个位置开始搜索。



##### 优化结果：

![image-20200330213452640](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200330213452640.png)

通过实验结果看出这种方式在时间效率上有较大的提升，因此选定这种fit方式。



#### 2. Place方式

基础算法中的place方式在一种可能性下会产生较大的空间浪费：

当堆按照“小 大 小 大....” 的方式进行分配，

![image-20200407175117842](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200407175117842.png)

接着又将所有大的块进行释放，

![image-20200407175338719](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200407175338719.png)

此时虽然程序中有许多空闲的大块，但因为这些大块并非连续，当一个较大块的需求来临时，可能会需要扩展堆，因此将产生许多外部碎片，所以将place函数进行改进，在分配时尽量将小的块与大的块分开放，place中对于大小块的划分标准根据trace文件与多次测试调整得出。

![image-20200407175741322](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200407175741322.png)

原来的place函数无论剩下的块大或小，都将分配块放在左边，新块放在右边。而改进后，当剩下的块可以分出一个大的新块时，我们将小块放在左边，大块移到右边；当剩下的块可以分出一个小的新块时，我们按照原来的palce方式将小块放在左边，大块放到右边。这样就能保证小块尽量放在左边，大块放在右边，避免上述产生外部碎片的情况，提升空间利用率。

~~~c++
static void *place(void *bp, size_t asize) {
  size_t csize = GET_SIZE(HDRP(bp));
  size_t left_size = csize - asize; //该块减去需要的大小剩余的大小
  void *next_bp = NULL;

  if ((left_size) < (2 * DSIZE)) {
    //如果剩余的大小不足以形成一个新块
    PUT(HDRP(bp), PACK(csize, 1));
    PUT(FTRP(bp), PACK(csize, 1));
    return bp;
  }

  else if (asize >= 96) {
    //剩余的大小可以分出一个大块
    PUT(HDRP(bp), PACK(left_size, 0));
    PUT(FTRP(bp), PACK(left_size, 0));
    next_bp = NEXT_BLKP(bp);
    PUT(HDRP(next_bp), PACK(asize, 1));
    PUT(FTRP(next_bp), PACK(asize, 1));
    return next_bp;
  }

  else {
    //剩余的大小可以分出一个小块
    PUT(HDRP(bp), PACK(asize, 1));
    PUT(FTRP(bp), PACK(asize, 1));
    next_bp = NEXT_BLKP(bp);
    PUT(HDRP(next_bp), PACK(left_size, 0));
    PUT(FTRP(next_bp), PACK(left_size, 0));
    return bp;
  }

  return bp;
}
~~~

##### 优化结果：

![image-20200406082422330](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200406082422330.png)

可以看到空间利用率上有一些提升。



#### 3. Realloc改进

先前的realloc函数在之前的各种改进下空间利用率都低于50%，效率很低，原因是当所需的size大于我们当前的size时，我们直接选择malloc函数来寻找一个新的空位，这样并没有充分利用到这个块周围的块。

实际上，当realloc需要更大的size时，我们可以判断这个块的前后是否是空闲块并且加上这些空闲块的空间是否就足够，如果足够了就利用前后块，这样能更连续地利用内存空间，减少外部碎片的产生。

~~~c++
void *mm_realloc(void *ptr, size_t size) {
  void *newptr = ptr;
  int left_size;

  // 如果size等于0，等同于free功能
  if (size == 0) {
    mm_free(ptr);
    return 0;
  }

  // 如果ptr为空，等同于malloc功能
  if (ptr == NULL) {
    return mm_malloc(size);
  }

  // 将size双字节对齐
  if (size <= DSIZE) {
    size = 2 * DSIZE;
  } else {
    size = ALIGN(size + DSIZE);
  }

  if ((left_size = GET_SIZE(HDRP(ptr)) - size) >= 0) {
    // 如果size小于原来块的大小，直接返回原来的块
    return ptr;
  }

  else if ((!GET_ALLOC(HDRP(NEXT_BLKP(ptr)))) &&
           ((left_size = GET_SIZE(HDRP(ptr)) + GET_SIZE(HDRP(NEXT_BLKP(ptr))) -
                         size) >= 0)) {
    //下一块是空闲块并且空间足够

    PUT(HDRP(ptr), PACK(size + left_size, 1));
    PUT(FTRP(ptr), PACK(size + left_size, 1));

  } else if ((!GET_ALLOC(HDRP(PREV_BLKP(ptr)))) &&
             ((left_size = GET_SIZE(HDRP(ptr)) +
                           GET_SIZE(HDRP(PREV_BLKP(ptr))) - size) >= 0)) {
    //上一块是空闲块并且空间足够

    newptr = PREV_BLKP(ptr);
    memcpy(newptr, ptr, GET_SIZE(HDRP(ptr)));
    PUT(HDRP(newptr), PACK(size + left_size, 1));
    PUT(FTRP(newptr), PACK(size + left_size, 1));
  } else if ((!GET_ALLOC(HDRP(NEXT_BLKP(ptr)))) &&
             (!GET_ALLOC(HDRP(PREV_BLKP(ptr)))) &&
             ((left_size = GET_SIZE(HDRP(ptr)) +
                           GET_SIZE(HDRP(NEXT_BLKP(ptr))) +
                           GET_SIZE(HDRP(PREV_BLKP(ptr))) - size) >= 0)) {

    //前后是空闲块并且空间足够
    newptr = PREV_BLKP(ptr);
    memcpy(newptr, ptr, GET_SIZE(HDRP(ptr)));
    PUT(HDRP(newptr), PACK(size + left_size, 1));
    PUT(FTRP(newptr), PACK(size + left_size, 1));
  } else {
    //  没有可以利用的连续free块
    newptr = mm_malloc(size);

    if (!newptr)
      return 0;

    memcpy(newptr, ptr, GET_SIZE(HDRP(ptr)));
    mm_free(ptr);
  }

  return newptr;
}
~~~



##### 优化结果：

![image-20200406100956699](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200406100956699.png)

可以看到改进的realloc使程序在空间利用率上有了显著的提升。



#### 4. INITCHUNKSIZE优化

我们最初在初始化堆和当找不到合适块的时候，采用将heap扩展CHUNKSIZE( 1<< 12 )大小的办法。根据实验数据发现，一开始程序可能不需要扩展这么大的空间，这样会产生一些空间浪费，因此在初始化堆的时候尝试调整初始扩展堆的大小。

~~~c++
// 扩展堆
extend_heap(INITCHUNKSIZE)
~~~



##### 优化结果：

![image-20200406154917979](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200406154917979.png)

优化下初始化堆大小增加了程序空间利用率，所有测试文件的利用率都达到了80%以上，获得了95分的性能分。



### 问题与解决方案

#### 1. 如何不使用结构体与全局变量

我们需要全局变量记录堆序言块heap_listp的指针，而且在Next_fit方法中需要记录上一次搜索的位置last_ptr。因为不允许使用结构体与全局变量，我们所能利用的只有这个堆。

因此在当需要使用序言块指针时，我们只需要调用mem_heap_lo函数获得堆的起始位置，然后再将其加上2个字的大小即可。

~~~c++
char *heap_listp = (char *)mem_heap_lo() + DSIZE;
~~~

Next_fit方法中的上一次搜索位置last_ptr可以将其存放在堆的起始位置的块。

![image-20200407175838693](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200407175838693.png)

利用宏定义GET与PUT方便last_ptr的存取

~~~c++
char *head = (char *)mem_heap_lo();
char *last_ptr = GET(head);  //last_ptr的取用
PUT(head, bp);				 //last_ptr的存放
~~~



#### 2. 调试过程中的各种Bug

编写与优化这个程序的时候出现了许多与指针相关的错误，如ran out of memory, segmantation fault, footer越界，realloc没有保护数据等，耗费了很多很多时间..

![image-20200405114720231](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200405114720231.png)

![image-20200407140305001](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200407140305001.png)

通过使用gdb进行调试以外，程序还添加了3个用于debug的函数printblock,checkheap,checkblock。

~~~c++
static void printblock(void *bp);
static void checkheap(int verbose);
static void checkblock(void *bp);
~~~



用于打印出来块的大小与分配情况，并检查堆内的一些具体错误情况，便于找到错误。

![image-20200407141047818](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200407141047818.png)





## 方法二：分离空闲链表

### 内存管理结构

分离空闲链表将所有空闲块分成一些大小类，这里我们按照2的幂来划分块大小：{1}, {2}, {3,4}, {5~8}, ..., {2^14 ~ ∞}共16个块，分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小的升序排列。当分配器需要一个大小为n的块时，采用分离适配方式，搜索相应大小的链表，不能找到合适的块时就搜索下一个链表。



**内存块**：与隐式空闲链表相同，内存分配块由头部、脚部、有效载荷与填充部分组成。而内存空闲块则添加了链表指针，便于找到空闲块在链表中的前后者。

![image-20200407192906299](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200407192906299.png)



**分离空闲链表数组**：分离空闲链表共有16个元素，对应{1}, {2}, {3,4}, {5~8}, ..., {2^14 ~ ∞}大小的空闲块，每个链表按照从小到大的顺序进行排序，便于找到合适的空闲块。

![image-20200411115229614](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200411115229614.png)



**堆的结构**：因为分离空闲链表需要一个空闲链表数组用于管理空闲块，因本实验不能使用全局变量，仿照前面next_fit方法中的last_ptr指针，将空闲链表放到堆的初始部分，序言块也因此向后移动16个块。同样的，在堆的结尾设4字节的结尾块。

![image-20200407192848818](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200407192848818.png)







### 算法思想

分离空闲链表基本上是在前面隐式空闲链表的架构上进行一些微调，下面展示一些不同点。

#### 宏定义

增加了关于方便分离空闲链表操作的一些宏定义，包括获取分离空闲链表头部，读写分离空闲链表，设置指针，存取块中前后指针NEXT,PREV。

~~~c++
//获取分离空闲链表头部
#define GET_LIST_HEAD() ((char *)mem_heap_lo() + WSIZE)

//读写分离空闲链表
#define LIST_PUT(head, num, val) (*(unsigned int *)(head + num * WSIZE) = (val))
#define LIST_GET(head, num) (*(unsigned int *)(head + num * WSIZE))

//把地址P中的指针设置为ptr
#define SET_PTR(p, ptr) (*(unsigned int *)(p) = (unsigned int)(ptr))

// 取块中存放NEXT与PREV地址的地址
#define NEXT_PTR(ptr) ((char *)(ptr))
#define PREV_PTR(ptr) ((char *)(ptr) + WSIZE)

//取块中存放的NEXT和PREV地址
#define NEXT(ptr) (*(char **)(ptr))
#define PREV(ptr) (*(char **)(PREV_PTR(ptr)))
~~~



#### 辅助函数

##### 1. insert_node

insert_node函数在free，extend_heap，coalesce，place中产生新空闲块时调用，向链表中插入大小为size的新空闲块结点。首先根据size，在分离空闲链表数组中找到对应这个size的链，链中的块按照从小到大的顺序排列，然后再在这个链中寻找对应的插入位置，分为四种情况，首次插入，在头部插入，在中间插入，在尾部插入，每种情况对应着不同的指针设置。

~~~c++
static void insert_node(void *ptr, size_t size) {
  int listnum = 0;
  void *search_ptr = NULL;
  void *insert_ptr = NULL;
  void *head = GET_LIST_HEAD();

  // 通过块的大小找到对应的链
  while ((listnum < LISTMAX - 1) && (size > 1)) {
    size >>= 1;
    listnum++;
  }

  // 在该链中寻找对应的插入位置，链中块由小到大
  search_ptr = LIST_GET(head, listnum);
  while ((search_ptr != NULL) && (size > GET_SIZE(HDRP(search_ptr)))) {
    insert_ptr = search_ptr;
    search_ptr = NEXT(search_ptr);
  }

  if (search_ptr != NULL) {
    // search指针不为空
    if (insert_ptr != NULL) {
      //在中间插入
      SET_PTR(NEXT_PTR(ptr), search_ptr);
      SET_PTR(PREV_PTR(search_ptr), ptr);
      SET_PTR(PREV_PTR(ptr), insert_ptr);
      SET_PTR(NEXT_PTR(insert_ptr), ptr);
    } else {
      // insert为空,在开头插入
      SET_PTR(NEXT_PTR(ptr), search_ptr);
      SET_PTR(PREV_PTR(search_ptr), ptr);
      SET_PTR(PREV_PTR(ptr), NULL);
      LIST_PUT(head, listnum, ptr);
    }
  } else {
    // search指针为空
    if (insert_ptr != NULL) {
      // search指针到了尾部,插入尾部
      SET_PTR(NEXT_PTR(ptr), NULL);
      SET_PTR(PREV_PTR(ptr), insert_ptr);
      SET_PTR(NEXT_PTR(insert_ptr), ptr);
    } else {
      // insert指针也为空,首次插入
      SET_PTR(NEXT_PTR(ptr), NULL);
      SET_PTR(PREV_PTR(ptr), NULL);
      LIST_PUT(head, listnum, ptr);
    }
  }
}
~~~



##### 2. delete_node

delete_node在malloc，realloc占用空闲块或coalesce合并空闲块时调用，删除链表中的某结点。同insert_node，delete_node函数先找到对应的链，然后根据ptr在链表中所在的位置的四种情况：链头，链尾，链中间，空链，对应不同的指针设置。

~~~c++
static void delete_node(void *ptr) {
  int listnum = 0;
  size_t size = GET_SIZE(HDRP(ptr));
  void *head = GET_LIST_HEAD();

  // 找到对应的链
  while ((listnum < LISTMAX - 1) && (size > 1)) {
    size >>= 1;
    listnum++;
  }

  if (NEXT(ptr) != NULL) {
    // 后一块不为空
    if (PREV(ptr) != NULL) {
      //前一块也不为空,处于中间
      SET_PTR(PREV_PTR(NEXT(ptr)), PREV(ptr));
      SET_PTR(NEXT_PTR(PREV(ptr)), NEXT(ptr));
    } else {
      //前一块为空,处于链头
      SET_PTR(PREV_PTR(NEXT(ptr)), NULL);
      LIST_PUT(head, listnum, NEXT(ptr));
    }
  } else {
    //后一块为空
    if (PREV(ptr) != NULL) {
      //前一块不空,为链尾
      SET_PTR(NEXT_PTR(PREV(ptr)), NULL);
    } else {
      //前一块也为空,为空链
      LIST_PUT(head, listnum, NULL);
    }
  }
}
~~~



#### 分配器函数

##### 1. mm_init

mm_init增加了初始化分离空闲链表数组部分，在初始化堆时留出16个块的大小，在16个块之后设置序言块，然后在将数组中的空闲链表全部设置为空链。

~~~c++
int mm_init(void) {
  //初始化堆
  char *heap_listp = 0;
  void *head = GET_LIST_HEAD();

  if ((long)(heap_listp = mem_sbrk(20 * WSIZE)) == -1)
    return -1;

  PUT(heap_listp, 0);
  PUT(heap_listp + (17 * WSIZE), PACK(DSIZE, 1));
  PUT(heap_listp + (18 * WSIZE), PACK(DSIZE, 1));
  PUT(heap_listp + (19 * WSIZE), PACK(0, 1));
  heap_listp += (18 * WSIZE);

  // 初始化分离空闲链表
  for (int listnum = 0; listnum < LISTMAX; listnum++) {
    LIST_PUT(head, listnum, NULL);
  }

  // 扩展堆
  if (extend_heap(INITCHUNKSIZE) == NULL)
    return -1;

  return 0;
}
~~~



##### 2. mm_malloc

mm_malloc函数寻找合适的块不再使用find_fit函数，而是在空闲链表中先找到对应的链，再匹配大小合适的空闲块，如果没有合适的空闲块就扩展堆。

~~~c++
void *mm_malloc(size_t size) {
  char *head = GET_LIST_HEAD();

  // 忽略虚假指令
  if (size == 0)
    return NULL;

  // 将size双字节对齐
  if (size <= DSIZE) {
    size = 2 * DSIZE;
  } else {
    size = ALIGN(size + DSIZE);
  }

  int listnum = 0;
  size_t searchsize = size;
  void *ptr = NULL;

  while (listnum < LISTMAX) {
    // 在链表中寻找匹配size的链
    if (((searchsize <= 1) && (LIST_GET(head, listnum) != NULL))) {
      // 如果size与这个链匹配 且 该链不为空 则选择该链
      ptr = (void *)LIST_GET(head, listnum);

      //在该链寻找大小合适的free块
      while ((ptr != NULL) && ((size > GET_SIZE(HDRP(ptr))))) {
        // 若该结点不为空 且 所需大小大于该结点 继续往前寻找
        ptr = NEXT(ptr);
      }

      // 找到ptr对应的空闲块
      if (ptr != NULL)
        break;
    }

    searchsize >>= 1; // size不匹配则继续往下一个链寻找
    listnum++;
  }

  // 没有找到合适的空闲块，则扩展堆
  if (ptr == NULL) {
    if ((ptr = extend_heap(MAX(size, CHUNKSIZE))) == NULL)
      return NULL;
  }

  // 找到空闲块，并分配该空闲块
  ptr = place(ptr, size);

  return ptr;
}
~~~





#### 其他函数

其他函数，包括mm_free,mm_realloc,extend_heap,coalesce,place都与隐式空间链表中的操作相同，只是在生成空闲块时加入insert_node将空闲块插入对应的分离空闲链表，占用空闲块时加入delete_node将空闲块在分离空闲链表中删除。



### 优化结果

![image-20200406142216806](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200406142216806.png)

可以看到分离空闲链表的内存管理结构相比隐式空闲链表在空间利用率上有所提升。



### 问题与解决方案

因为有了隐式空闲链表的基础，分离空闲链表中的问题较少，扩大堆头部的空闲块用作分离空闲链表数组来代替全局变量和结构体，debug结合gdb和printblock,checkheap,checkblock函数，取得了较好的效果。



## 总结反思

隐式空闲链表最终取得了95分的性能分。

![image-20200407193849459](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200407193849459.png)

分离空闲链表最终取得了98分的性能分。

![image-20200407193954177](C:\Users\a1185\AppData\Roaming\Typora\typora-user-images\image-20200407193954177.png)

实验中的一些部分参考了CSAPP和网上博客的思路，以后要争取自己想出更好的办法。

在实验的过程中花了很长的时间进行debug，走了一些弯路，老是忘记改变一些细节，然后以为是整体架构问题又重新思考，最后发现是一个很小的细节点，浪费了较多时间，以后更加细心，继续努力。







